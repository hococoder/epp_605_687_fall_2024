<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Mobile Application Development for the iOS Platform"/><link rel="canonical" href="https://hococoder.com/posts/Week03/04-IntroductionToCoreData"/><meta name="twitter:url" content="https://hococoder.com/posts/Week03/04-IntroductionToCoreData"/><meta name="og:url" content="https://hococoder.com/posts/Week03/04-IntroductionToCoreData"/><title>Week 3 - Introduction to Core Data | Mobile Application Development for the iOS Platform</title><meta name="twitter:title" content="Week 3 - Introduction to Core Data | Mobile Application Development for the iOS Platform"/><meta name="og:title" content="Week 3 - Introduction to Core Data | Mobile Application Development for the iOS Platform"/><meta name="description" content="A description of my first post."/><meta name="twitter:description" content="A description of my first post."/><meta name="og:description" content="A description of my first post."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><link rel="stylesheet" href="../../../styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Mobile Application Development for the iOS Platform"/></head><body><header><div class="wrapper"><a class="site-name" href="/">Mobile Application Development for the iOS Platform</a><nav><ul><li><a href="/epp_605_687_spring_2024/posts/Intro/About Me">AboutMe</a></li><li><a href="/epp_605_687_spring_2024/posts/Intro/Example App">ExampleApp</a></li><li><a href="/epp_605_687_spring_2024/posts/Week00/00-Week00Overview">Week0</a></li><li><a href="/epp_605_687_spring_2024/posts/Week01/00-Week01Overview">Week1</a></li><li><a href="/epp_605_687_spring_2024/posts/Week02/00-Week02Overview">Week2</a></li><li><a href="/epp_605_687_spring_2024/posts/Week03/00-Week03Overview">Week3</a></li><li><a href="/epp_605_687_spring_2024/posts/Week04/00-Week04Overview">Week4</a></li><li><a href="/epp_605_687_spring_2024/posts/Week05/00-Week05Overview">Week5</a></li><li><a href="/epp_605_687_spring_2024/posts/Week06/00-Week06Overview">Week6</a></li><li><a href="/epp_605_687_spring_2024/posts/Week07/00-Week07Overview">Week7</a></li><li><a href="/epp_605_687_spring_2024/posts/Week08/00-Week08Overview">Week8</a></li><li><a href="/epp_605_687_spring_2024/posts/Week09/00-Week09Overview">Week9</a></li><li><a href="/epp_605_687_spring_2024/posts/Week10/00-Week10Overview">Week10</a></li><li><a href="/epp_605_687_spring_2024/posts/Week11/00-Week11Overview">Week11</a></li><li><a href="/epp_605_687_spring_2024/posts/Week12/00-Week12Overview">Week12</a></li><li><a href="/epp_605_687_spring_2024/posts/Week13/00-Week13Overview">Week13</a></li></ul></nav></div></header><div class="wrapper"><h1>Week 3 - Introduction to Core Data</h1><p style="float: left">Previous:  <A HREF="../03-IntroductionToTheCodableProtocol/index.html">Introduction to the Codable Protocol</A></p><p style="float: right">Next:  <A HREF="../05-SettingUpASchema/index.html" class="nextModule">Setting Up a Schema</A></p><BR/><BR/><h2>What is Core Data?</h2><p>Sometimes a series of a flat files just won’t work for your app’s data - you really need a database. The Core Data framework provides an interface to a sqlite database that reside in the directory structure of your app. Core Data does so much for you, in fact, that Apple claims the amount of code that you need to manage the database drops 50-70% over a standard database implementation. It also provides you with features like:</p><ul><li>Maintaining relationship consistency</li><li>Loading objects lazily (or only when they are needed)</li><li>Validating property values</li><li>Tools to help with schema migration</li><li>The ability to make sophisticated queries.</li></ul><p>Let's go over how to configure your app to use Core Data, and what Xcode gives you when you do so.</p><h2>Configuring your app for Core Data</h2><center> <iframe width="1280" height="720" src="https://cdnapisec.kaltura.com/html5/html5lib/v2.81.2/mwEmbedFrame.php/p/1458241/uiconf_id/14487351/entry_id/1_bwm7r4zj?wid=_1458241&iframeembed=true&playerId=kaltura_player&entry_id=1_bwm7r4zj&flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[mediaProxy.preferedFlavorBR]=2500&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;flashvars[EmbedPlayer.NotPlayableDownloadLink]=true;&wid=1_abkvs1gz"allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Kaltura Player">
  </iframe>
</center><p>When you start a new project with Xcode and choose the iOS App template, you can choose to have Core Data support added for free, which includes:</p><ul><li>A <code>Persistence.swift</code> file to initialize the Core Data stack</li><li>An <code>.xcdatamodeld</code> file that allows you to define the entities, queries and configurations for your database.</li><li>NOTE: Other templates that don’t have this option can have the code and files added on after project creation.</li></ul><img src="../../../week03/NewSingleViewOptions.png#centerResizedSlide" alt="Options for a new Single View App"/><p>The project that opens up is pretty similar to the project that would be created without the Core Data option selected, but with a few differences. First, the project now contains a <code>Persistence.swift</code> file. Inside this file, a <code>PersistenceController</code> struct is defined. Let's look at the various parts of this struct:</p><pre><code><span class="keyword">import</span> CoreData

<span class="keyword">struct</span> PersistenceController {
    <span class="keyword">static let</span> shared = <span class="type">PersistenceController</span>()
</code></pre><p>First, the <code>CoreData</code> framework is imported, the struct is declared, and a static instance of the struct is also declared. This is important - it will allow us to reference the global <code>PersistenceController</code> from wherever we are in our app.</p><pre><code>     <span class="keyword">static var</span> preview: <span class="type">PersistenceController</span> = {
        <span class="keyword">let</span> result = <span class="type">PersistenceController</span>(inMemory: <span class="keyword">true</span>)
        <span class="keyword">let</span> viewContext = result.<span class="property">container</span>.<span class="property">viewContext</span>
        <span class="keyword">for _ in</span> <span class="number">0</span>..&lt;<span class="number">10</span> {
            <span class="keyword">let</span> newItem = <span class="type">Item</span>(context: viewContext)
            newItem.<span class="property">timestamp</span> = <span class="type">Date</span>()
        }
        <span class="keyword">do</span> {
            <span class="keyword">try</span> viewContext.<span class="call">save</span>()
        } <span class="keyword">catch</span> {
            <span class="comment">// Replace this implementation with code to handle the error appropriately.
            // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.</span>
            <span class="keyword">let</span> nsError = error <span class="keyword">as</span> <span class="type">NSError</span>
            <span class="call">fatalError</span>(<span class="string">"Unresolved error</span> \(nsError)<span class="string">,</span> \(nsError.<span class="property">userInfo</span>)<span class="string">"</span>)
        }
        <span class="keyword">return</span> result
    }()
</code></pre><p>Next, a second static instance, <code>preview</code> of the <code>PersistenceController</code> is created. Why do we need two? During development when you're working with the preview canvas, it's useful to have a <code>PersistenceController</code> - and its associated items - that is only available to your preview canvas, and in memory only. This keeps any data you may use during UI testing out of the main database the simulator would reference, which makes things a bit cleaner in the long run, and also allows you to clear out the <code>viewContext</code>s separately if you so desire. This fixes a problem that previous versions of Xcode had where it was very hard to manage the preview canvas' database.<br><br>So, what does this do? First, it's a computed static property - it is defined inline, and created the first time it is referenced. First, it makes an instance of the <code>PersistenceController</code> in memory by passing <code>true</code> to the <code>inMemory</code> argument. This means for the purposes of our preview canvas, the database solely exists in memory and doesn't get written to disk. Next a <code>viewContext</code> property (of type <code>NSManagedObjectContext</code>) is established from the <code>PersistenceController</code>'s container. In iOS parlance, a context is like a scratch space (we'll see this used later on in the semester when we discuss <code>CoreImage</code>). In Core Data terms, the context will allow us to make all the necessary modifications to the entities we want to store in the database <strong>before</strong> we actually save it, meaning we can make one save instead of several, increasing our efficiency.</p><p>Once we have that context in hand, we can make some database entries. The App template defines an <code>Item</code> entity, and here, a for loop is used to create 10 <code>Item</code> objects using the <code>viewContext</code> we defined earlier. Think about this like creating 10 instance of the <code>Item</code> type in our scratch space before we save them to the database. Then with a <code>do/catch</code> block, attempt to save the <code>viewContext</code> to the database via <code>viewContext.save()</code>. The template uses a <code>fatalError</code> call in case there is an error, but notes that you should replace that code with proper error handling code in your shipping application. This methodology - create some instances, modify them, and then save the context, is a pattern we will see again, so keep it in mind. Lastly, the <code>result</code> object, representing the <code>PersistenceController</code> is returned.</p><pre><code>     <span class="keyword">let</span> container: <span class="type">NSPersistentContainer</span>
</code></pre><p>An <code>NSPersistentContainer</code> container object is defined as a constant, which will get initialized in the <code>init</code> method below.</p><pre><code>     <span class="keyword">init</span>(inMemory: <span class="type">Bool</span> = <span class="keyword">false</span>) {
        container = <span class="type">NSPersistentContainer</span>(name: <span class="string">"EPExampleApp"</span>)
        <span class="keyword">if</span> inMemory {
            container.<span class="property">persistentStoreDescriptions</span>.<span class="property">first</span>!.url = <span class="type">URL</span>(fileURLWithPath: <span class="string">"/dev/null"</span>)
        }
        container.<span class="call">loadPersistentStores</span>(completionHandler: { (storeDescription, error) <span class="keyword">in
            if let</span> error = error <span class="keyword">as</span> <span class="type">NSError</span>? {
                <span class="comment">// Replace this implementation with code to handle the error appropriately.
                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.

                /*
                Typical reasons for an error here include:
                * The parent directory does not exist, cannot be created, or disallows writing.
                * The persistent store is not accessible, due to permissions or data protection when the device is locked.
                * The device is out of space.
                * The store could not be migrated to the current model version.
                Check the error message to determine what the actual problem was.
                */</span>
                <span class="call">fatalError</span>(<span class="string">"Unresolved error</span> \(error)<span class="string">,</span> \(error.<span class="property">userInfo</span>)<span class="string">"</span>)
            }
        })
        container.<span class="property">viewContext</span>.<span class="property">automaticallyMergesChangesFromParent</span> = <span class="keyword">true</span>
    }
}
</code></pre><p>Here's the <code>init</code> method for the struct. First, it declares a new <code>NSPersistentContainer</code> which takes in a name - in our case, we're using the <code>EPExampleApp</code> name. As we saw earlier, the <code>init</code> method takes in a <code>Bool</code> to declare whether it is in memory or not. If that argument is true, the first entry in the <code>persistentStoreDescriptions</code> array of the container is set to a <code>URL</code> with "/dev/null" as the path before it attempts to load the persistent stores for the container. Those stores are of type <code>NSPersistentStore</code>, and natively, Core Data supports the following types:</p><ul><li><code>NSSQLiteStoreType</code> - this is backed by a SQLite database, and is the only non-atomic store type, meaning it can be written and read piecemeal instead of all at once. This is the default type used by Xcode</li><li><code>NSXMLStoreType</code> - An atomic store type backed by a XML file. This makes it human readable, but can have a large memory footprint. This is only on macOS.</li><li><code>NSBinaryStoreType</code>- An atomic store type backed by a binary file. This is rarely used, but available as an option.</li><li><code>NSInMemoryStoreType</code> - As the name suggests, this is an in memory store, which means it really isn't "persistent". This type can be useful for unit testing, or previewing items in the Preview Canvas.</li></ul><p>Once the store is created, the entire Core Data stack is created (there are multiple pieces of this stack; but for the purposes of this class, this is the interface to the stack you need to concern yourself with).</p><p style="float: left">Previous:  <A HREF="../03-IntroductionToTheCodableProtocol/index.html">Introduction to the Codable Protocol</A></p><p style="float: right">Next:  <A HREF="../05-SettingUpASchema/index.html" class="nextModule">Setting Up a Schema</A></p></div><footer><p>Generated with ❤️ using <a href="https://github.com/johnsundell/publish">Publish</a></p><p>© 2023-2024 Josh Steele (rsteele3@jhu.edu) <a href="mailto:"(rsteele3@jhu.edu)""></a></p><p>Last updated January 21, 2024 at 1:48 PM</p><p><a href="https://mastodon.social/@hococoder" target="_blank">My Mastodon</a> | <a href="https://github.com/hococoder" target="_blank">My GitHub</a> | <a href="https://ep.jhu.edu" target="_blank">Whiting School EPP</a> | <a href="https://canvas.jhu.edu" target="_blank">JHU Canvas</a></p></footer></body></html>