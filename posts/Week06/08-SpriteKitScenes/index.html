<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Mobile Application Development for the iOS Platform"/><link rel="canonical" href="https://hococoder.com/posts/Week06/08-SpriteKitScenes"/><meta name="twitter:url" content="https://hococoder.com/posts/Week06/08-SpriteKitScenes"/><meta name="og:url" content="https://hococoder.com/posts/Week06/08-SpriteKitScenes"/><title>Week 6 - SpriteKit Nodes and Scenes | Mobile Application Development for the iOS Platform</title><meta name="twitter:title" content="Week 6 - SpriteKit Nodes and Scenes | Mobile Application Development for the iOS Platform"/><meta name="og:title" content="Week 6 - SpriteKit Nodes and Scenes | Mobile Application Development for the iOS Platform"/><meta name="description" content="A description of my first post."/><meta name="twitter:description" content="A description of my first post."/><meta name="og:description" content="A description of my first post."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><link rel="stylesheet" href="../../../styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Mobile Application Development for the iOS Platform"/></head><body><header><div class="wrapper"><a class="site-name" href="/">Mobile Application Development for the iOS Platform</a><nav><ul><li><a href="/epp_605_687_spring_2024/posts/Intro/About Me">AboutMe</a></li><li><a href="/epp_605_687_spring_2024/posts/Intro/Example App">ExampleApp</a></li><li><a href="/epp_605_687_spring_2024/posts/Week00/00-Week00Overview">Week0</a></li><li><a href="/epp_605_687_spring_2024/posts/Week01/00-Week01Overview">Week1</a></li><li><a href="/epp_605_687_spring_2024/posts/Week02/00-Week02Overview">Week2</a></li><li><a href="/epp_605_687_spring_2024/posts/Week03/00-Week03Overview">Week3</a></li><li><a href="/epp_605_687_spring_2024/posts/Week04/00-Week04Overview">Week4</a></li><li><a href="/epp_605_687_spring_2024/posts/Week05/00-Week05Overview">Week5</a></li><li><a href="/epp_605_687_spring_2024/posts/Week06/00-Week06Overview">Week6</a></li><li><a href="/epp_605_687_spring_2024/posts/Week07/00-Week07Overview">Week7</a></li><li><a href="/epp_605_687_spring_2024/posts/Week08/00-Week08Overview">Week8</a></li><li><a href="/epp_605_687_spring_2024/posts/Week09/00-Week09Overview">Week9</a></li><li><a href="/epp_605_687_spring_2024/posts/Week10/00-Week10Overview">Week10</a></li><li><a href="/epp_605_687_spring_2024/posts/Week11/00-Week11Overview">Week11</a></li><li><a href="/epp_605_687_spring_2024/posts/Week12/00-Week12Overview">Week12</a></li><li><a href="/epp_605_687_spring_2024/posts/Week13/00-Week13Overview">Week13</a></li></ul></nav></div></header><div class="wrapper"><h1>Week 6 - SpriteKit Nodes and Scenes</h1><p style="float: left">Previous:  <A HREF="../07-IntroductionToSpriteKit/index.html">Introduction to SpriteKit</A></p><p style="float: right">Next:  <A HREF="../09-SpriteKitActions/index.html" class="nextModule">SpriteKit Actions</A></p><BR/><BR/><h2>Overview</h2><p><code>SKNode</code>s are the base class for the elements of <code>SpriteKit</code>. Nodes positions are specified relative to their parent’s coordinate system, and can set properties for their contents, and their descendant’s content (so for example, when a node is scaled, the child nodes get scaled as well)</p><p><code>SKScene</code>s are a descendent of <code>SKNode</code>, and act as the root nodes for the <code>SKNode</code>s you’ll display on screen. When you use the <code>SpriteKit</code> game template, a <code>GameScene</code> class is generated in the template that extends <code>SKScene</code>. An <code>SKScene</code>’s size defines its visible area, but you can place objects outside that area - they just aren’t rendered, very similar to a <code>UIView</code>. What’s different from normal views is that <code>SKScene</code>s have their origin in the LOWER left instead of the UPPER left.</p><p>An <code>SKView</code> is similar to a <code>UIView</code>, and handles the presentation of a <code>SKScene</code>. It can also do things like show the frame count and node count on screen.</p><h3>Changing Node Shapes</h3><p>You can also change the shape of a node if it adopts the <code>SKWarpable</code> protocol. Such nodes have a <code>warpGeometry</code> property, which can immediately take a warping, or the warping can be done over time with the <code>warp(to:duration:)</code> method. You can get more advanced in your warping by using a <code>SKWarpGeometryGrid</code> to define the exact warping you want to take place.</p><h3>Other nodes</h3><p>2 other types of nodes that can be added to a scene are <code>SKCameraNodes</code> and <code>SKLightNodes</code>.</p><ul><li><code>SKCameraNode</code>s represent a position in space where the scene can be rendered from, and since it’s a node, it can acted upon - so it can be moved, or have physics applied to it (which we’ll talk about next).</li><li><code>SKLightNode</code>s represent lights in the scene. For light to interact with an object, the light must be enabled, be in the scene, and have a non-zero lighting bit mask with a node to have that node lit.</li></ul><h3>The Xcode Scene Editor</h3><p>Xcode comes with a very handy scene editor for working with <code>SpriteKit</code>. It allows you to build many pieces of your <code>SpriteKit</code> scene without having to use a lot of underlying source code. In many ways, the scene editor is like <code>UIKit</code>'s Interface Builder for <code>SpriteKit</code>.</p><p>Here’s a screenshot of the scene editor when you start a project with the <code>SpriteKit</code> Game template. As you can see - it does indeed look a lot like Interface builder. On the left is an outline view, showing the scene and its descendants. In the middle, the sprite kit scene is in the place just like the Interface Builder storyboard. On the right hand side there are property editors in the upper portion, and objects can be selected and placed into the scene via the normal Library button (the + button, where you can also get SwiftUI views and modifiers). The scene editor allows you to add sprite, camera nodes, reference nodes (that can be use to reuse parts of the scene), and light nodes among others.<br><br><img src="../../../week06/Slide40.png#centerResizedSlide" alt="Scene Editor"/></p><p>In these examples, we'll be focusing on doing things in code; but keep the editor in mind!</p><p>Let's look at how to add a <code>SpriteKit</code> scene to our example app.</p><h2>Example</h2><center> <iframe width="1280" height="720" src="https://cdnapisec.kaltura.com/html5/html5lib/v2.81.2/mwEmbedFrame.php/p/1458241/uiconf_id/14487351/entry_id/1_weta2qis?wid=_1458241&iframeembed=true&playerId=kaltura_player&entry_id=1_weta2qis&flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[mediaProxy.preferedFlavorBR]=2500&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;flashvars[EmbedPlayer.NotPlayableDownloadLink]=true;&wid=1_abkvs1gz"allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Kaltura Player">
  </iframe>
</center><p>Let's build a SpriteKit view that pays homage to one of my favorite Sci-Fi franchises - <em>Star Trek</em>. In the EPExample app, I've loaded the project with some images that I’ll use during the creation of the scene. Let’s take a quick look at those. I have a very low res version of the Enterprise, a generic asteroid shape, an image of a front shield, and a series of backgrounds I can use to create a star field. Let’s start by adding the ship, its shields, and some asteroids for it to avoid.</p><h3>Adding and Manipulating Sprites</h3><p>Start by adding a new Swift file called <code>GameScene.swift</code> that extends <code>SKScene</code> (if you start with a SpriteKit based project, this file is made for you; we're extending the capabilities of the example app, which used a different template, so we're adding it manually). Don't forget to <code>import SceneKit</code>.</p><p>Let’s start by adding the ship and its shields in the form of SKSpriteNode properties. Follow that up with an overridden function - <code>sceneDidLoad()</code> that will handle the initialization of our objects. Call the <code>addShip()</code> and <code>addShield()</code> methods which will define shortly. <code>sceneDidLoad()</code> is called once after the view loads, so it's great for one-time initialization of objects.</p><pre><code><span class="keyword">class</span> GameScene: <span class="type">SKScene</span> {

  <span class="keyword">var</span> ship: <span class="type">SKSpriteNode</span>!
  <span class="keyword">var</span> shield: <span class="type">SKSpriteNode</span>!

  <span class="keyword">override func</span> sceneDidLoad() {
  
    <span class="call">addShip</span>()
    <span class="call">addShield</span>()
  }
</code></pre><p>If you recall from the overview video, a sprite can be simply identified with a PNG. So, let’s add a method to build and place the ship, and one to place the shields.</p><pre><code>   <span class="keyword">func</span> addShip()
  {
    ship = <span class="type">SKSpriteNode</span>(imageNamed: <span class="string">"enterprise"</span>)
    ship.<span class="property">xScale</span> = <span class="number">0.5</span>
    ship.<span class="property">yScale</span> = <span class="number">0.5</span>
    ship.<span class="property">position</span> = <span class="type">CGPoint</span>(x: size.<span class="property">width</span>*<span class="number">0.22</span>, y: size.<span class="property">height</span>*<span class="number">0.5</span>)
    <span class="keyword">self</span>.<span class="call">addChild</span>(ship)
  }

  <span class="keyword">func</span> addShield()
  {
    shield = <span class="type">SKSpriteNode</span>(imageNamed: <span class="string">"shield"</span>)
    shield.<span class="property">xScale</span> = <span class="number">0.5</span>
    shield.<span class="property">yScale</span> = <span class="number">0.5</span>
    shield.<span class="property">position</span> = <span class="type">CGPoint</span>(x: size.<span class="property">width</span>*<span class="number">0.30</span>, y: size.<span class="property">height</span>*<span class="number">0.5</span>)
    
    <span class="keyword">self</span>.<span class="call">addChild</span>(shield)
  }
</code></pre><p>I've determined these locations myself, but this could be something that the Scene Editor could do easily for you if you went that route.</p><p>For each sprite, we create it using the name of the PNG, scale it appropriately for our scene, place it in the scene using the <code>position</code> property, and add it to the <code>SKView</code>. The ship is placed about mid way down the height of the screen, over to the left, and the shields are placed to be in front of the ship.</p><p>Before we can take a look at this in the simulator, we have to get it inside a SwiftUI view like I mentioned earlier. There are 2 things we need to do. First, add the following method to the GameScene.swift:</p><pre><code>   <span class="keyword">override func</span> didChangeSize(<span class="keyword">_</span> oldSize: <span class="type">CGSize</span>) {
    <span class="keyword">if</span> size != .<span class="dotAccess">zero</span>
    {
      <span class="keyword">guard</span> ship != <span class="keyword">nil</span>, shield != <span class="keyword">nil else</span> { <span class="keyword">return</span> }
      ship.<span class="property">position</span> = <span class="type">CGPoint</span>(x: size.<span class="property">width</span>*<span class="number">0.22</span>, y: size.<span class="property">height</span>*<span class="number">0.5</span>)
      shield.<span class="property">position</span> = <span class="type">CGPoint</span>(x: size.<span class="property">width</span>*<span class="number">0.30</span>, y: size.<span class="property">height</span>*<span class="number">0.5</span>)
    }
  }
</code></pre><p>This method will update the position of the sprites as the view they are in changes size. This way if SwiftUI updates the size, we can update accordingly.<br><br><br></p><p class="new"> This next part has been GREATLY simplified, thanks to the introduction of the new `SpriteView` in iOS 14. </p><p>Second, use the new <code>SpriteView</code> in iOS 14 to load up that scene (in iOS 13 you had to use a <code>UIViewRepresentable</code> because there wasn't a native SwiftUI widget). Make a new file called <code>SpriteKitViewExample</code> and add this code to it</p><pre><code><span class="keyword">import</span> SwiftUI
<span class="keyword">import</span> SpriteKit

<span class="keyword">struct</span> SpriteKitViewExample: <span class="type">View</span> {
  
  <span class="keyword">var</span> scene: <span class="type">SKScene</span> {
    <span class="keyword">let</span> scene = <span class="type">GameScene</span>()
    scene.<span class="property">scaleMode</span> = .<span class="dotAccess">resizeFill</span>
    <span class="keyword">return</span> scene
  }
  
  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="type">SpriteView</span>(scene: scene)
      .<span class="call">ignoresSafeArea</span>()
  }
}

<span class="keyword">struct</span> SpriteKitViewExample_Previews: <span class="type">PreviewProvider</span> {
  <span class="keyword">static var</span> previews: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="type">SpriteKitViewExample</span>()
  }
}
</code></pre><p>A computed property <code>scene</code> is initialized with a <code>GameScene</code> and the scale mode is set to <code>resizeFill</code> to help it fill the frame.</p><p>In addition to defining the normal functions for <code>UIViewRepresentable</code> it also sets up some properties on the <code>SKView</code> like showing the frames per second. Add a call to Week06View.swift to add an new tab</p><pre><code><span class="type">SpriteKitViewExample</span>().<span class="property">tabItem</span>{<span class="type">Text</span>(<span class="string">"SpriteKit"</span>)}
</code></pre><p>Let’s run this now - as you can expect, it looks pretty plain. But - the ship and shields are there! We'll add something later to run into the shields - asteroids!</p><p style="float: left">Previous:  <A HREF="../07-IntroductionToSpriteKit/index.html">Introduction to SpriteKit</A></p><p style="float: right">Next:  <A HREF="../09-SpriteKitActions/index.html" class="nextModule">SpriteKit Actions</A></p></div><footer><p>Generated with ❤️ using <a href="https://github.com/johnsundell/publish">Publish</a></p><p>© 2023-2024 Josh Steele (rsteele3@jhu.edu) <a href="mailto:"(rsteele3@jhu.edu)""></a></p><p>Last updated January 21, 2024 at 1:48 PM</p><p><a href="https://mastodon.social/@hococoder" target="_blank">My Mastodon</a> | <a href="https://github.com/hococoder" target="_blank">My GitHub</a> | <a href="https://ep.jhu.edu" target="_blank">Whiting School EPP</a> | <a href="https://canvas.jhu.edu" target="_blank">JHU Canvas</a></p></footer></body></html>