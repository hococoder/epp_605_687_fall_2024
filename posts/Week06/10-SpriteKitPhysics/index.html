<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Mobile Application Development for the iOS Platform"/><link rel="canonical" href="https://hococoder.com/posts/Week06/10-SpriteKitPhysics"/><meta name="twitter:url" content="https://hococoder.com/posts/Week06/10-SpriteKitPhysics"/><meta name="og:url" content="https://hococoder.com/posts/Week06/10-SpriteKitPhysics"/><title>Week 6 - SpriteKit Physics | Mobile Application Development for the iOS Platform</title><meta name="twitter:title" content="Week 6 - SpriteKit Physics | Mobile Application Development for the iOS Platform"/><meta name="og:title" content="Week 6 - SpriteKit Physics | Mobile Application Development for the iOS Platform"/><meta name="description" content="A description of my first post."/><meta name="twitter:description" content="A description of my first post."/><meta name="og:description" content="A description of my first post."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><link rel="stylesheet" href="../../../styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Mobile Application Development for the iOS Platform"/></head><body><header><div class="wrapper"><a class="site-name" href="/">Mobile Application Development for the iOS Platform</a><nav><ul><li><a href="/epp_605_687_spring_2024/posts/Intro/About Me">AboutMe</a></li><li><a href="/epp_605_687_spring_2024/posts/Intro/Example App">ExampleApp</a></li><li><a href="/epp_605_687_spring_2024/posts/Week00/00-Week00Overview">Week0</a></li><li><a href="/epp_605_687_spring_2024/posts/Week01/00-Week01Overview">Week1</a></li><li><a href="/epp_605_687_spring_2024/posts/Week02/00-Week02Overview">Week2</a></li><li><a href="/epp_605_687_spring_2024/posts/Week03/00-Week03Overview">Week3</a></li><li><a href="/epp_605_687_spring_2024/posts/Week04/00-Week04Overview">Week4</a></li><li><a href="/epp_605_687_spring_2024/posts/Week05/00-Week05Overview">Week5</a></li><li><a href="/epp_605_687_spring_2024/posts/Week06/00-Week06Overview">Week6</a></li><li><a href="/epp_605_687_spring_2024/posts/Week07/00-Week07Overview">Week7</a></li><li><a href="/epp_605_687_spring_2024/posts/Week08/00-Week08Overview">Week8</a></li><li><a href="/epp_605_687_spring_2024/posts/Week09/00-Week09Overview">Week9</a></li><li><a href="/epp_605_687_spring_2024/posts/Week10/00-Week10Overview">Week10</a></li><li><a href="/epp_605_687_spring_2024/posts/Week11/00-Week11Overview">Week11</a></li><li><a href="/epp_605_687_spring_2024/posts/Week12/00-Week12Overview">Week12</a></li><li><a href="/epp_605_687_spring_2024/posts/Week13/00-Week13Overview">Week13</a></li></ul></nav></div></header><div class="wrapper"><h1>Week 6 - SpriteKit Physics</h1><p style="float: left">Previous:  <A HREF="../09-SpriteKitActions/index.html">SpriteKit Actions</A></p><p style="float: right">Next:  <A HREF="../11-SpriteKitBackgrounds/index.html" class="nextModule">SpriteKit Backgrounds</A></p><BR/><BR/><h2>Overview</h2><p><code>SKScene</code>s come with a member called <code>physicsWorld</code> - of type <code>SKPhysicsWorld</code> - by default. That object uses a delegate that adopts the <code>SKPhysicsContactDelegate</code> to help apply physics based principles such as gravity, simulation speed and other forces.</p><p>You can attach <code>SKPhysicsBody</code> objects to your nodes to allow them to respond to the laws of physics in the world. A physics body is defined by the shape, size, mass, and other characteristics of the node.</p><p>In addition to being acted upon by things such as gravity, the physics bodies can interact with one another. If the scene adopts a <code>SKPhysicsContactDelegate</code> protocol, it can determine how the different types of bodies interact with one another. The bodies have 2 different bitmasks, a <code>categoryBitMask</code> and <code>contactTestBitMask</code>, that determine what interactions take place. When 2 bodies come into contact, you can get back the impulse of the collision, the contact point, and the normal vector specifying the direction of the collision.</p><p>You can also make established connections between bodies in your scene. You can connect bodies together with springs, pins, and fixed connections among others. As objects are moved, you can get force and torque values against the anchor point.</p><p>Finally, in the realm of SceneKit physics, you may not want to always apply physics effects to your entire scene. You can use a <code>SKFieldNode</code> to override a scene’s default physics attributes, allowing you to change them at will. Physics bodies can also dictate which field will affect them, so you can combine the 2 to configure the exact interactions you want in your scene.</p><h3>Detecting collisions</h3><center> <iframe width="1280" height="720" src="https://cdnapisec.kaltura.com/html5/html5lib/v2.81.2/mwEmbedFrame.php/p/1458241/uiconf_id/14487351/entry_id/1_0g7ielzi?wid=_1458241&iframeembed=true&playerId=kaltura_player&entry_id=1_0g7ielzi&flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[mediaProxy.preferedFlavorBR]=2500&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;flashvars[EmbedPlayer.NotPlayableDownloadLink]=true;&wid=1_abkvs1gz"allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Kaltura Player">
  </iframe>
</center><p>Let’s fix the y direction drift in the asteroids travel first. By default, each scene has a physicsWorld object on it that has a non-zero value for gravity. That’s why the asteroids are drifting downward - they feel a tug from gravity in the downward direction. Let’s define a new function called addPhysics to fix this. Here, let’s define the physicsWorld’s gravity to be a vector with 0 components in both the x and y direction.</p><pre><code>   <span class="keyword">func</span> addPhysics()
  {
    physicsWorld.<span class="property">gravity</span> = <span class="type">CGVector</span>(dx: <span class="number">0</span>, dy: <span class="number">0</span>)
    physicsWorld.<span class="property">contactDelegate</span> = <span class="keyword">self</span>
  }
</code></pre><p>While we’re here, let’s setup the contactDelegate for the physicsWorld object to be self - and for that, we’ll need to have our class adopt the SKPhysicsContactDelegate protocol. We’ll implement one of the optional methods on this protocol shortly.</p><pre><code><span class="keyword">class</span> GameScene: <span class="type">SKScene</span>, <span class="type">SKPhysicsContactDelegate</span> {
</code></pre><p>Let’s start by adding two methods to our code - one called configureShieldPhysics, and the other called configureAsteroidPhysics. Before we populate those, let’s define a struct that identifies the objects in our code that can collide. We’ll give each thing a unique number that we can bit mask against to check for a collision. Call the struct PhysicsCategory, and define 4 static members: None, with value 0, All with value UInt32.max, Asteroid with value 0b1, and Shield with 0b10. These are all UInt32 values.</p><pre><code><span class="keyword">struct</span> PhysicsCategory
{
  <span class="keyword">static let</span> <span class="type">None</span>    : <span class="type">UInt32</span> = <span class="number">0</span>
  <span class="keyword">static let</span> <span class="type">All</span>     : <span class="type">UInt32</span> = <span class="type">UInt32</span>.<span class="property">max</span>
  <span class="keyword">static let</span> <span class="type">Asteroid</span> : <span class="type">UInt32</span> = 0b1  <span class="comment">//1</span>
  <span class="keyword">static let</span> <span class="type">Shield</span>   : <span class="type">UInt32</span> = 0b10 <span class="comment">//2</span>
}
</code></pre><p>Let’s use that in our configureShieldPhysics method. First, initialize the shield’s physicsBody, giving it a circular shape with a radius of the shield’s width divided by 2. Then set the isDynamic value to false. This flag dictates whether the shield is effected by the physics simulation. Here we don’t want it responding to things like gravity so we’ll set it to false. Then, setup our bitmasks. The category bitmask is of course “Shield”. We’re concerned here about contacts with asteroids, so that’s our choice for the contactTestBitMask. We’re not worried about collisions - and the possible physics that happens due to a collision - so we’ll set the collisionBitMask to None. Related to this we don’t need a precise collision detection, so we’ll set this to false.</p><pre><code>   <span class="keyword">func</span> configureShieldPhysics()
  {
    shield.<span class="property">physicsBody</span> = <span class="type">SKPhysicsBody</span>(circleOfRadius: shield.<span class="property">size</span>.<span class="property">width</span>/<span class="number">2</span>)
    shield.<span class="property">physicsBody</span>?.<span class="property">isDynamic</span> = <span class="keyword">false</span>
    shield.<span class="property">physicsBody</span>?.<span class="property">categoryBitMask</span> = <span class="type">PhysicsCategory</span>.<span class="type">Shield</span>
    shield.<span class="property">physicsBody</span>?.<span class="property">contactTestBitMask</span> = <span class="type">PhysicsCategory</span>.<span class="type">Asteroid</span>
    shield.<span class="property">physicsBody</span>?.<span class="property">collisionBitMask</span> = <span class="type">PhysicsCategory</span>.<span class="type">None</span>
    shield.<span class="property">physicsBody</span>?.<span class="property">usesPreciseCollisionDetection</span> = <span class="keyword">false</span>
  }
</code></pre><p>Add a call for this to the <code>addShield()</code> method:</p><pre><code>   <span class="call">configureShieldPhysics</span>()
</code></pre><p>The asteroid is setup in a similar way, with a few differences. The size of the physics body is rectangular, and the isDynamic flag is set to true - we want the asteroids to respond to the physical world (more on this later). The bit masks are setup in a similar fashion to the shields.</p><pre><code>   <span class="keyword">func</span> configureAsteroidPhysics(asteroid:<span class="type">SKSpriteNode</span>)
  {
    asteroid.<span class="property">physicsBody</span> = <span class="type">SKPhysicsBody</span>(rectangleOf: asteroid.<span class="property">size</span>)
    asteroid.<span class="property">physicsBody</span>?.<span class="property">isDynamic</span> = <span class="keyword">true</span>
    asteroid.<span class="property">physicsBody</span>?.<span class="property">categoryBitMask</span> = <span class="type">PhysicsCategory</span>.<span class="type">Asteroid</span>
    asteroid.<span class="property">physicsBody</span>?.<span class="property">contactTestBitMask</span> = <span class="type">PhysicsCategory</span>.<span class="type">Shield</span>
    asteroid.<span class="property">physicsBody</span>?.<span class="property">collisionBitMask</span> = <span class="type">PhysicsCategory</span>.<span class="type">None</span>
    asteroid.<span class="property">physicsBody</span>?.<span class="property">usesPreciseCollisionDetection</span> = <span class="keyword">false</span>
  }
</code></pre><p>Add the configureAsteroidPhysics method to the addAsteroid method.</p><pre><code>   <span class="call">configureAsteroidPhysics</span>(asteroid: asteroid)
</code></pre><p>OK, one more thing to do with collisions. We need to tell the physics world - via the SKPhysicsContactDelegate protocol - how to handle our collisions. One of the two methods on that protocol is didBegin, so use autocomplete to get that method in place for you. Each collision in our example consists of 2 bodies, one of which is the asteroid. We want to check if there are collisions between it and the shields.</p><p>To properly assign the firstBody to the asteroid, let’s check the bit masks for each body. If you recall from our PhysicsCategory structure, the asteroid had value 1, and the shields had value 2. A pair of bodies are colliding - represented by either "Shield, Asteroid" or "Asteroid, Shield". I want to remove the asteroid if it collides the shield, so a quick comparison of the bitmasks lets me see which one is the asteroid. Let’s add a quick check to make sure that the firstBody’s node isn’t nil - if so we’ll just return right away, which is a great use for a guard statement. At this point, we know that an asteroid has impacted the shield, so go ahead and remove the asteroid from the parent.</p><pre><code>   <span class="keyword">func</span> didBegin(<span class="keyword">_</span> contact: <span class="type">SKPhysicsContact</span>) {
    <span class="keyword">var</span> firstBody:<span class="type">SKPhysicsBody</span>
    
    <span class="keyword">if</span> contact.<span class="property">bodyA</span>.<span class="property">categoryBitMask</span> &lt; contact.<span class="property">bodyB</span>.<span class="property">categoryBitMask</span>
    {
      firstBody = contact.<span class="property">bodyA</span>
    }
    <span class="keyword">else</span>
    {
      firstBody = contact.<span class="property">bodyB</span>
    }
    
    <span class="keyword">guard</span> firstBody.<span class="property">node</span> != <span class="keyword">nil else</span> { <span class="keyword">return</span> }
    (firstBody.<span class="property">node</span> <span class="keyword">as</span>! <span class="type">SKSpriteNode</span>).<span class="call">removeFromParent</span>()
  }
</code></pre><p>Let’s run this and see what happens - it may take a bit for an asteroid that collides, but when it does it correctly disappears from the scene.</p><p>In the next module, we'll look into adding a background so it looks like the ship is in....spaaaaaace!</p><p style="float: left">Previous:  <A HREF="../09-SpriteKitActions/index.html">SpriteKit Actions</A></p><p style="float: right">Next:  <A HREF="../11-SpriteKitBackgrounds/index.html" class="nextModule">SpriteKit Backgrounds</A></p></div><footer><p>Generated with ❤️ using <a href="https://github.com/johnsundell/publish">Publish</a></p><p>© 2023-2024 Josh Steele (rsteele3@jhu.edu) <a href="mailto:"(rsteele3@jhu.edu)""></a></p><p>Last updated January 21, 2024 at 1:48 PM</p><p><a href="https://mastodon.social/@hococoder" target="_blank">My Mastodon</a> | <a href="https://github.com/hococoder" target="_blank">My GitHub</a> | <a href="https://ep.jhu.edu" target="_blank">Whiting School EPP</a> | <a href="https://canvas.jhu.edu" target="_blank">JHU Canvas</a></p></footer></body></html>